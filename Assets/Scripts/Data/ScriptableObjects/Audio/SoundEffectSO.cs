using UnityEngine;
using Random = UnityEngine.Random;
using MoreMountains.Tools;
using Sirenix.OdinInspector;
using Cysharp.Threading.Tasks;
using System.Collections.Generic;

[CreateAssetMenu(fileName = "NewSoundEffect", menuName = "Audio/New Sound Effect")]
public class SoundEffectSO : ScriptableObject
{
    [Title("Sound")]
    [Tooltip("an array to pick a random sfx from")]
    public AudioClip[] Clips;
    [Tooltip("if this is true, random sfx audio clips will be played in sequential order instead of at random")]
    public bool SequentialOrder = false;
    [Tooltip("if we're in sequential order, determines whether or not to hold at the last index, until either a cooldown is met, or the ResetSequentialIndex method is called")]
    [ShowIf("SequentialOrder")]
    public bool SequentialOrderHoldLast = false;
    [Tooltip("if we're in sequential order hold last mode, index will reset to 0 automatically after this duration, unless it's 0, in which case it'll be ignored")]
    [ShowIf("SequentialOrderHoldLast")]
    public float SequentialOrderHoldCooldownDuration = 2f;
    [Tooltip("if this is true, sfx will be picked at random until all have been played. once this happens, the list is shuffled again, and it starts over")]
    public bool RandomUnique = false;
    [Tooltip("whether or not there should be a limit for max concurrent sounds")]
    public bool LimitMaxConcurrentSounds = false;
    [Tooltip("whether or not there should be a limit for max concurrent sounds")]
    [ShowIf("LimitMaxConcurrentSounds")]
    public int MaxConcurrentSounds = 7;

    [Title("Sound Properties")]
    [Header("Volume")]
    [Tooltip("the minimum volume to play the sound at")]
    [Range(0f, 2f)]
    public float MinVolume = 1f;
    [Tooltip("the maximum volume to play the sound at")]
    [Range(0f, 2f)]
    public float MaxVolume = 1f;

    [Header("Pitch")]
    [Tooltip("the minimum pitch to play the sound at")]
    [Range(-3f, 3f)]
    public float MinPitch = 1f;
    [Tooltip("the maximum pitch to play the sound at")]
    [Range(-3f, 3f)]
    public float MaxPitch = 1f;

    [Title("Sound Manager Options")]
    [Tooltip("the track on which to play the sound. Pick the one that matches the nature of your sound")]
    public MMSoundManager.MMSoundManagerTracks MmSoundManagerTrack = MMSoundManager.MMSoundManagerTracks.Sfx;
    [Tooltip("the ID of the sound. This is useful if you plan on using sound control feedbacks on it afterwards.")]
    public int ID = 0;
    [Tooltip("whether or not this sound should loop")]
    public bool Loop = false;
    [Tooltip("whether or not this sound should continue playing when transitioning to another scene")]
    public bool Persistent = false;
    [Tooltip("whether or not this sound should play if the same sound clip is already playing")]
    public bool DoNotPlayIfClipAlreadyPlaying = false;

    [Title("Fade")]
    [Tooltip("whether or not to fade this sound in when playing it")]
    public bool Fade = false;
    [Tooltip("if fading, the volume at which to start the fade")]
    [ShowIf("Fade")]
    public float FadeInitialVolume = 0f;
    [Tooltip("if fading, the duration of the fade, in seconds")]
    [ShowIf("Fade")]
    public float FadeDuration = 1f;
    [Tooltip("if fading, the tween over which to fade the sound ")]
    [ShowIf("Fade")]
    public MMTweenType FadeTween = new(MMTween.MMTweenCurve.EaseInOutQuartic);

    [Title("Solo")]
    [Tooltip("whether or not this sound should play in solo mode over its destination track. If yes, all other sounds on that track will be muted when this sound starts playing")]
    public bool SoloSingleTrack = false;
    [Tooltip("whether or not this sound should play in solo mode over all other tracks. If yes, all other tracks will be muted when this sound starts playing")]
    public bool SoloAllTracks = false;
    [Tooltip("if in any of the above solo modes, AutoUnSoloOnEnd will unmute the track(s) automatically once that sound stops playing")]
    public bool AutoUnSoloOnEnd = false;

    [Title("Spatial Settings")]
    [Tooltip("Pans a playing sound in a stereo way (left or right). This only applies to sounds that are Mono or Stereo.")]
    [Range(-1f, 1f)]
    public float PanStereo;
    [Tooltip("Sets how much this AudioSource is affected by 3D spatialisation calculations (attenuation, doppler etc). 0.0 makes the sound full 2D, 1.0 makes it full 3D.")]
    [Range(0f, 1f)]
    public float SpatialBlend;

    [Title("Effects")]
    [Tooltip("Bypass effects (Applied from filter components or global listener filters).")]
    public bool BypassEffects = false;
    [Tooltip("When set global effects on the AudioListener will not be applied to the audio signal generated by the AudioSource. Does not apply if the AudioSource is playing into a mixer group.")]
    public bool BypassListenerEffects = false;
    [Tooltip("When set doesn't route the signal from an AudioSource into the global reverb associated with reverb zones.")]
    public bool BypassReverbZones = false;
    [Tooltip("Sets the priority of the AudioSource.")]
    [Range(0, 256)]
    public int Priority = 128;
    [Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones.")]
    [Range(0f, 1.1f)]
    public float ReverbZoneMix = 1f;

    [Title("3D Sound Settings")]
    [Tooltip("Sets the Doppler scale for this AudioSource.")]
    [Range(0f, 5f)]
    public float DopplerLevel = 1f;
    [Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space.")]
    [Range(0, 360)]
    public int Spread = 0;
    [Tooltip("Sets/Gets how the AudioSource attenuates over distance.")]
    public AudioRolloffMode RolloffMode = AudioRolloffMode.Logarithmic;
    [Tooltip("Within the Min distance the AudioSource will cease to grow louder in volume.")]
    public float MinDistance = 1f;
    [Tooltip("(Logarithmic rolloff) MaxDistance is the distance a sound stops attenuating at.")]
    public float MaxDistance = 500f;
    [Tooltip("whether or not to use a custom curve for custom volume rolloff")]
    public bool UseCustomRolloffCurve = false;
    [Tooltip("the curve to use for custom volume rolloff if UseCustomRolloffCurve is true")]
    [ShowIf("UseCustomRolloffCurve")]
    public AnimationCurve CustomRolloffCurve;
    [Tooltip("whether or not to use a custom curve for spatial blend")]
    public bool UseSpatialBlendCurve = false;
    [Tooltip("the curve to use for custom spatial blend if UseSpatialBlendCurve is true")]
    [ShowIf("UseSpatialBlendCurve")]
    public AnimationCurve SpatialBlendCurve;
    [Tooltip("whether or not to use a custom curve for reverb zone mix")]
    public bool UseReverbZoneMixCurve = false;
    [Tooltip("the curve to use for custom reverb zone mix if UseReverbZoneMixCurve is true")]
    [ShowIf("UseReverbZoneMixCurve")]
    public AnimationCurve ReverbZoneMixCurve;
    [Tooltip("whether or not to use a custom curve for spread")]
    public bool UseSpreadCurve = false;
    [Tooltip("the curve to use for custom spread if UseSpreadCurve is true")]
    [ShowIf("UseSpreadCurve")]
    public AnimationCurve SpreadCurve;

    protected AudioClip _randomClip;
    protected MMSoundManagerPlayOptions _options;
    protected List<AudioSource> _activeAudioSources;
    protected AudioSource _activeAudioSource;
    protected AudioSource _editorAudioSource;

    private void OnEnable()
    {
        _activeAudioSources = new();
    }

    /// <summary>
    /// Triggers a play sound event with desired options
    /// </summary>
    /// <param name="position"></param>
    /// <param name="volumeMultiplier"></param>
    /// <param name="attachToTransform"></param>
    public void Play(Vector3 position, float volumeMultiplier = 1f, Transform attachToTransform = null)
    {
        if (LimitMaxConcurrentSounds && _activeAudioSources.Count >= MaxConcurrentSounds)
        {
            return;
        }

        if (Clips.Length > 0)
        {
            _randomClip = Clips[Random.Range(0, Clips.Length)];

            if (_randomClip != null)
            {
                PlaySound(_randomClip, position, volumeMultiplier, attachToTransform);
            }
        }
    }

    /// <summary>
    /// Stop looping sound if needed
    /// </summary>
    public void StopLoopingSound(bool fade)
    {
        if (_activeAudioSource != null)
        {
            if (fade)
                FadeTask().Forget();
            else
                _activeAudioSource.Stop();
        }
    }

    private async UniTaskVoid FadeTask()
    {
        MMSoundManagerSoundFadeEvent.Trigger(MMSoundManagerSoundFadeEvent.Modes.PlayFade, ID, FadeDuration, FadeInitialVolume, FadeTween);
        await UniTask.WaitForSeconds(FadeDuration, ignoreTimeScale: true);
        _activeAudioSource.Stop();
    }

    /// <summary>
    /// Triggers a play sound event
    /// </summary>
    /// <param name="sfx"></param>
    /// <param name="position"></param>
    /// <param name="intensity"></param>
    private void PlaySound(AudioClip sfx, Vector3 position, float intensity, Transform attachToTransform)
    {
        if (DoNotPlayIfClipAlreadyPlaying)
        {
            if (MMSoundManager.Instance.FindByClip(sfx) != null)
            {
                return;
            }
        }

        float volume = Random.Range(MinVolume, MaxVolume) * intensity;
        float pitch = Random.Range(MinPitch, MaxPitch);

        _options.MmSoundManagerTrack = MmSoundManagerTrack;
        _options.Location = position;
        _options.Loop = Loop;
        _options.Volume = volume;
        _options.ID = ID;
        _options.Fade = Fade;
        _options.FadeInitialVolume = FadeInitialVolume;
        _options.FadeDuration = FadeDuration;
        _options.FadeTween = FadeTween;
        _options.Persistent = Persistent;
        _options.Pitch = pitch;
        _options.PanStereo = PanStereo;
        _options.SpatialBlend = SpatialBlend;
        _options.SoloSingleTrack = SoloSingleTrack;
        _options.SoloAllTracks = SoloAllTracks;
        _options.AutoUnSoloOnEnd = AutoUnSoloOnEnd;
        _options.BypassEffects = BypassEffects;
        _options.BypassListenerEffects = BypassListenerEffects;
        _options.BypassReverbZones = BypassReverbZones;
        _options.Priority = Priority;
        _options.ReverbZoneMix = ReverbZoneMix;
        _options.DopplerLevel = DopplerLevel;
        _options.Spread = Spread;
        _options.RolloffMode = RolloffMode;
        _options.MinDistance = MinDistance;
        _options.MaxDistance = MaxDistance;
        _options.AttachToTransform = attachToTransform;

        var source = MMSoundManagerSoundPlayEvent.Trigger(sfx, _options);
        if (!Loop)
        {
            ClipLifeCycleTask(source).Forget();
        }
        else
        {
            _activeAudioSource = source;
        }
    }

    private async UniTaskVoid ClipLifeCycleTask(AudioSource source)
    {
        _activeAudioSources.Add(source);
        await UniTask.WaitForSeconds(source.clip.length, ignoreTimeScale: true);
        _activeAudioSources.Remove(source);
    }

    #region TestMethods
    /// <summary>
    /// A test method that creates an audiosource, plays it, and destroys itself after play
    /// </summary>
    [Button]
    public void TestPlaySound()
    {
        TestPlaySoundTask().Forget();
    }

    private async UniTaskVoid TestPlaySoundTask()
    {
        AudioClip tmpAudioClip = null;

        if (Clips.Length > 0)
        {
            tmpAudioClip = Clips[Random.Range(0, Clips.Length)];
        }

        if (tmpAudioClip == null)
        {
            Debug.LogError(name + " can't play in editor mode, you haven't set its Sfx.");
            return;
        }

        float volume = Random.Range(MinVolume, MaxVolume);
        float pitch = Random.Range(MinPitch, MaxPitch);
        GameObject temporaryAudioHost = new("EditorTestAS_WillAutoDestroy");
        _editorAudioSource = temporaryAudioHost.AddComponent<AudioSource>();
        PlayAudioSource(_editorAudioSource, tmpAudioClip, volume, pitch, 0);
        float length = tmpAudioClip.length;
        length /= Mathf.Abs(pitch);
        await UniTask.WaitForSeconds(length);
        DestroyImmediate(temporaryAudioHost);
    }

    /// <summary>
    /// A test method that stops the test sound
    /// </summary>
    [Button]
    public void TestStopSound()
    {
        if (_editorAudioSource != null)
        {
            _editorAudioSource.Stop();
            DestroyImmediate(_editorAudioSource.gameObject);
        }
    }

    /// <summary>
    /// Plays the audio source with the specified volume and pitch
    /// </summary>
    /// <param name="audioSource"></param>
    /// <param name="sfx"></param>
    /// <param name="volume"></param>
    /// <param name="pitch"></param>
    private void PlayAudioSource(AudioSource audioSource, AudioClip sfx, float volume, float pitch, int timeSamples)
    {
        // we set that audio source clip to the one in paramaters
        audioSource.clip = sfx;
        audioSource.timeSamples = timeSamples;
        // we set the audio source volume to the one in parameters
        audioSource.volume = volume;
        audioSource.pitch = pitch;
        // we set our loop setting
        audioSource.loop = false;
        // we start playing the sound
        audioSource.Play();
    }

    #endregion
}
